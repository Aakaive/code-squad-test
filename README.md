# code-squad-test
## 1단계 : 카드게임 구현하기
- 카드 덱에는 1~8까지의 카드가 세 장씩 총 24장이 들어있다.
- 게임을 시작하면 카드 덱의 카드를 랜덤하게 섞는다.
- 카드를 섞어둔 덱에서 카드를 18장 순서대로 뽑아와서 3행 6열로 배치한다.
### 1. standbyPhase
- 모든 카드가 뒤집어져 있는 상태로 출력한다. (뒤집힌 카드는 X로 표시하고, 카드 사이는 공백으로 표시한다.)
- 콘솔에는 시도 횟수, 남은 카드, 입력 메시지를 표시한다.
- 플레이어는 (1, 1) ~ (3, 6)까지 카드 위치에 해당하는 좌표를 두 번 입력한다.
### 2. openPhase
- 플레이어가 입력한 위ㅊ의 카드를 뒤집어서 카드의 종류를 보여준다.
- 두 카드가 일치할 경우, 해당 카드를 제거하고 남은 카드를 출력한다.
### 3. endPhase
- 모든 카드를 맞추거나 더 이상 남은 짝이 없을 경우 축하메시지를 출력하고 종료한다.
### 4. loop
- 게임이 끝나지 않을 경우 standbyPhase로 돌아가서 반복한다.

## 1단계 : 초안 구상
- 랜덤으로 섞은 덱에서 18장의 카드를 뽑는다. => 선형 리스트를 통하여 shuffle 하고, 리스트 분리 메소드를 이용하여 순서대로 카드를 뽑는다.
- 카드 전체를 출력한다.(뒤집은 카드는 종류에 맞는 정수, 뒤집어진 카드는 X, 이미 짝을 맞춘 카드는 공백을 출력하는 for문을 이용한다.)
- 카드 두장의 좌표를 입력받는다. => 카드가 선형리스트로 이루어져있으므로, 좌표를 선형 인덱스로 변환한다.
- 카드 리스트의 인덱스를 통하여 일치 여부를 판별하고, 결과에 맞는 작업을 수행한다.
- 짝이 맞은 카드의 값을 0으로 초기화하여 짝을 맞춘 카드를 식별한다.
- 한 턴이 끝나고, 게임을 종료할지에 대한 체크를 수행한다.
- stream의 distinct 메소드를 활용하여 중복체크(짝이 맞는 카드가 남아 있는가)를 실행하고, frequency 메소드로 0(이미 짝을 맞춘 카드)을 판별하여 게임 속행 여부를 결정한다.

## 1단계 Solution 01 : main을 통한 러프한 구현
### 1. settingPhase : 변수 선언 및 카드 테이블 설정
- 1~8까지의 숫자카드 24장을 저장한 정수 배열 deck
- deck을 저장한 리스트 card
- card에서 18장의 카드만 순서대로 뽑아서 저장한 리스트 table
- 선택할 카드의 위치를 입력받을 정수 변수 numX1, numY1, numX2, numY2
- 테이블 위에 올려진 카드를 1차원 리스트로 표현하였기 때문에, x와 y인덱스를 1차원 인덱스로 변환한 numIdx1, numIdx2를 생성한다.
- 카드 뒤집기를 시도한 횟수를 저장하는 open 변수와, 테이블 위에 남은 카드의 매수를 저장하는 remain 변수.
### 2. standbyPhase : 게임을 시작한다.
- 정수 변수 count를 이용하여 테이블 리스트의 인덱스를 탐색한다.(초기값 0)
- for문을 이용하여 리스트에 저장된 카드들을 출력한다.(count를 활용하여 6장을 출력할 때마다 줄바꿈을 실행한다.)
- 테이블에 저장된 카드의 값이 0일 경우, 이미 짝을 맞추어 테이블에서 제외된 카드이므로 "공백"을 출력한다.
- 그 외의 경우에는 X를 출력하여 뒤집어진 상태의 카드를 표현한다.
- 뒤집을 카드를 선택한다.
### 3. openPhase : 카드를 뒤집어 본다.
- 뒤집을 카드가 인덱스 범위를 넘어갈 경우, 혹은 같은 위치일 경우 예외 메시지를 출력하고 standbyPhase로 복귀한다.
- 입력받은 두 카드의 위치를 인덱스로 변환한다.(numIdx)
- 테이블 리스트를 탐색하여 선택한 카드의 종류를 표시한 채로 테이블 전체를 출력한다.(for문 활용)
- 두 카드의 종류가 일치할 경우, 남은 카드 매수를 2 차감하고 해당 카드의 값을 0으로 초기화한다.
### 4. endPhase : 게임종료 조건을 확인하고, 게임을 종료한다.
- 중복체크를 활용하여 게임 속행 여부를 판단한다.
- 게임종료 조건(모든 카드를 맞추거나, 더 이상 남아 있는 짝이 없을 경우)을 충족할 경우, 남은 카드들을 전부 뒤집어서 출력하고 게임을 종료한다.
### 5. loop : 게임종료 조건이 충족되지 않을 경우, standbyPhase로 돌아가 반복한다.

## 1단계 Solution 02 : 메소드를 통한 main의 간결화 및 전역 변수 최소화
### 1. settingPhase : 변수 선언 및 카드 테이블 설정
- 1~8까지의 숫자카드 24장을 저장한 정수 배열 deck
- deck를 새로이 정의한 메소드 shuffleCard(Integer[] arr)을 사용하여 카드 덱을 셔플한 뒤 18장을 순서대로 뽑는다.
- 뽑은 카드는 정수 리스트 Card에 저장한다.
### 2. standbyPhase : 게임을 시작한다.
- showCardTale(List<Integer> Card, Command cmd) 메소드를 사용하여 게임 테이블 위에 놓여진 카드를 출력한다.
- 게임 테이블에 남아 있는 카드는 'X'로, 짝을 맞춘 카드(0으로 초기화)의 경우 공백으로 표현한다.
- Command는 새로이 정의한 명령어로, 속성으로는 BLIND와 CHECK를 가진다.
- BLIND는 뒤집어진 카드들을 출력하는 명령어이고, CHECK는 게임종료 조건을 충족할 경우 테이블에 남아 있는 카드의 종류를 출력하는 명령어이다.
- 해당 상태에서는 선택할 카드 두 장의 좌표를 입력 받는 메시지를 출력한다.
- 카드 두 장의 선택 범위는 각기 col(1~6), row(1~3)으로, 입력 받은 col과 row를 이용하여 Card 리스트를 참조하기 위한 selectedCardIdx를 계산한다.
### 3. openPhase : 선택한 카드를 뒤집어서 확인해본다.
- openCard(List<Integer> Card, int selectedCardIdx1, int selectedCardIdx2) 메소드를 사용하여 선택한 두 장의 카드를 뒤집은 상태의 게임 테이블을 출력한다.
- 뒤집은 카드는 해당 카드의 종류를 표현한 정수로 출력하고, 뒤집어진 카드는 그대로 'X'로 표현하여 출력한다.
- 뒤집은 두 장의 카드의 종류가 일치할 경우, 해당 카드의 값을 0으로 초기화하여 식별하며, 남은 카드의 수를 2 차감한다.
### 4. endPhase : 턴을 종료한다.
- 카드를 뒤집은 횟수(turn)을 1 증가시킨다.
- 짝을 맞춰 0으로 초기화하지 않은 카드 중에서, 짝이 맞는 카드가 남아 있을 경우 다시 standbyPhase로 돌아가 위의 과정을 반복한다.
- 짝이 맞는 카드가 남아 있지 않을 경우, showCardTabld(List<Integer> Card, Command cmd) 메소드를 사용하여 명령어 CHECK로 짝이 맞지 않아 남아 있는 카드의 종류를 전부 드러내 테이블 전체를 출력한다.
- 축하메시지를 출력한 후 게임을 종료한다.

## 2단계 : 2인 게임으로 구현하기
- 프로그램을 시작하면 참가자 1P와 2P의 이름을 입력받고, 1P부터 게임을 시작한다.
- 플레이어 스코어 표시 기능을 추가한다.
- 카드 맞추기에 성공한 플레이어는 다시 입력 찬스가 주어진다.
- 참가자가 카드를 한 번 맞추면 10점이다. 만약 연속으로 맞출 경우 획득 점수가 두 배씩 증가한다.
- 모든 카드를 맞추고 나면 게임을 종료한다.
- 게임 종료 시 각 플레이어별 스코어와 승리자를 표시한다.

## 2단계 초안 구상
- player 객체 선언으로, 이름과 점수를 가진 player 객체를 만들어서 관리한다.
- 연속 맞추기 찬스와 획득 스코어 증가에 관한 수행을 구현한다.(1P 혹은 2P 중 누구의 턴인지 식별하기 위한 식별자가 필요하다. boolean은 어떨까?)